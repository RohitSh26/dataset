
<Window x:Class="YourNamespace.YourWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        xmlns:local="clr-namespace:YourNamespace" <!-- Replace with your actual namespace -->
        Title="Your Window" Height="450" Width="800">

    <Grid>
        <dxg:GridControl x:Name="grid" ItemsSource="{Binding Invoices}">
            <!-- Columns -->
            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="InvoiceType" GroupIndex="0" AllowSorting="False"/>
                <dxg:GridColumn FieldName="InvoiceNumber" AllowSorting="False"/>
                <dxg:GridColumn FieldName="ProductName" AllowSorting="False"/>
                <dxg:GridColumn FieldName="Price" AllowSorting="False"/>
            </dxg:GridControl.Columns>

            <!-- TableView -->
            <dxg:GridControl.View>
                <dxg:TableView x:Name="view">
                    <dxg:TableView.RowCellMenuCustomizations>
                        <!-- Remove the built-in menu items -->
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.SortAscending}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.SortDescending}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.ClearSorting}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.GroupByThisColumn}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.UngroupThisColumn}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.ShowGroupPanel}"/>
                        <RemoveAction ElementName="{x:Static dxg:DefaultColumnMenuItemNamesBase.HideGroupPanel}"/>
                    </dxg:TableView.RowCellMenuCustomizations>

                    <!-- Group Row Template -->
                    <dxg:TableView.GroupRowTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <TextBlock Text="{Binding Value}" Margin="4"/>
                            </StackPanel>
                        </DataTemplate>
                    </dxg:TableView.GroupRowTemplate>
                    
                    <!-- Additional TableView properties like ShowSearchPanel, ShowGroupPanel can be set to False here -->
                    <dxg:TableView.ShowSearchPanel>false</dxg:TableView.ShowSearchPanel>
                    <dxg:TableView.ShowGroupPanel>false</dxg:TableView.ShowGroupPanel>
                </dxg:TableView>
            </dxg:GridControl.View>
        </dxg:GridControl>
    </Grid>
</Window>





using System;
using System.Globalization;
using System.Windows.Data;

public class BoolToExpandCollapseSymbolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is bool isExpanded)
        {
            return isExpanded ? "-" : "+";
        }
        return null;
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}


<dxg:GridControl x:Name="grid" ItemsSource="{Binding Invoices}">
    <!-- ... other settings ... -->
    <dxg:GridControl.View>
        <dxg:TableView x:Name="view">
            <dxg:TableView.GroupRowTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock x:Name="ExpandCollapseIndicator" Text="+" Margin="4"/>
                        <TextBlock Text="{Binding Value}" Margin="4"/>
                    </StackPanel>
                    <DataTemplate.Triggers>
                        <DataTrigger Binding="{Binding RowData.IsExpanded}" Value="True">
                            <Setter TargetName="ExpandCollapseIndicator" Property="Text" Value="-"/>
                        </DataTrigger>
                    </DataTemplate.Triggers>
                </DataTemplate>
            </dxg:TableView.GroupRowTemplate>
        </dxg:TableView>
    </dxg:GridControl.View>
</dxg:GridControl>







Certainly, sticking to the MVVM paradigm involves moving the logic into the ViewModel and using commands or events that the view can bind to. Here's how you could achieve the same effect using MVVM.

### Model
```csharp
public class Invoice
{
    public string ProductName { get; set; }
    public double Price { get; set; }
    public double Discount { get; set; }
    public string InvoiceType { get; set; }
}
```

### ViewModel

```csharp
public class InvoiceViewModel : INotifyPropertyChanged
{
    private ObservableCollection<Invoice> _invoices;

    public ObservableCollection<Invoice> Invoices
    {
        get { return _invoices; }
        set
        {
            _invoices = value;
            OnPropertyChanged(nameof(Invoices));
        }
    }

    public InvoiceViewModel()
    {
        Invoices = new ObservableCollection<Invoice>
        {
            new Invoice { ProductName = "Apple", Price = 1.2, Discount = 0, InvoiceType = "Food" },
            new Invoice { ProductName = "Banana", Price = 0.8, Discount = 0, InvoiceType = "Food" },
            // More data here
        };
    }

    public void DuplicateRows(string groupValue)
    {
        var invoicesInGroup = Invoices.Where(i => i.InvoiceType.Equals(groupValue)).Skip(1).ToList();

        foreach (var invoice in invoicesInGroup)
        {
            int index = Invoices.IndexOf(invoice);
            Invoices.Insert(index + 1, new Invoice
            {
                ProductName = invoice.ProductName,
                Price = invoice.Price,
                Discount = invoice.Discount,
                InvoiceType = invoice.InvoiceType
            });
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### View (MainWindow.xaml)

```xaml
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        Title="MainWindow" Height="350" Width="525">
    <Grid>
        <dxg:GridControl x:Name="grid" ItemsSource="{Binding Invoices}">
            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="ProductName"/>
                <dxg:GridColumn FieldName="Price"/>
                <dxg:GridColumn FieldName="Discount"/>
                <dxg:GridColumn FieldName="InvoiceType" GroupIndex="0"/>
            </dxg:GridControl.Columns>
            <dxg:GridControl.View>
                <dxg:TableView x:Name="view"/>
            </dxg:GridControl.View>
        </dxg:GridControl>
    </Grid>
</Window>
```

### Code-behind for View (MainWindow.xaml.cs)

```csharp
using DevExpress.Xpf.Grid;
using System.Windows;

namespace WpfApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            var viewModel = new InvoiceViewModel();
            this.DataContext = viewModel;

            // Use EventToCommandBehavior or interaction triggers to connect this to ViewModel in a more MVVM-compliant way
            this.grid.GroupRowExpanded += (sender, e) =>
            {
                if (e.RowHandle != GridControl.InvalidRowHandle)
                {
                    var groupValue = grid.GetGroupRowValue(e.RowHandle);
                    if (groupValue != null)
                    {
                        viewModel.DuplicateRows(groupValue.ToString());
                    }
                }
            };
        }
    }
}
```

In this code, the event `GroupRowExpanded` still exists in the code-behind, but it simply forwards the call to the ViewModel. You can replace this with an MVVM-compliant behavior or interaction trigger. The logic for duplicating the rows now resides in the ViewModel, adhering to the MVVM principles.