version https://git-lfs.github.com/spec/v1
oid sha256:1588a43a89f9bb85cb0dc46a10e3b26780a2964d8768efdcafcaedb6123e7a2f
size 104857600

<Window x:Class="ExpandableDataGridExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid"
        Title="Expandable Data Grid Example" Height="400" Width="600">
    <Grid>
        <xcdg:DataGridControl Name="ExpandableDataGrid" AutoCreateColumns="False" ItemsSource="{Binding Persons}">
            <xcdg:DataGridControl.Columns>
                <!-- Expand/Collapse Column -->
                <xcdg:Column FieldName="IsExpanded" Title="">
                    <xcdg:Column.CellContentTemplate>
                        <DataTemplate>
                            <Button Content="{Binding RelativeSource={RelativeSource Self}, Path=DataContext, Converter={StaticResource BoolToExpandCollapseConverter}}"
                                    Command="{Binding DataContext.ToggleExpandCollapseCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                                    CommandParameter="{Binding}"/>
                        </DataTemplate>
                    </xcdg:Column.CellContentTemplate>
                </xcdg:Column>
                <!-- Other Columns -->
                <xcdg:Column FieldName="Name" Title="Name" />
                <xcdg:Column FieldName="Age" Title="Age" />
            </xcdg:DataGridControl.Columns>
        </xcdg:DataGridControl>
    </Grid>
</Window>

<Window x:Class="ExpandableDataGridExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:xcdg="http://schemas.xceed.com/wpf/xaml/datagrid"
        Title="Expandable Data Grid Example" Height="400" Width="600">
    <Grid>Certainly! Implementing this functionality using MVVM (Model-View-ViewModel) promotes separation of concerns and testability. Below is an example that demonstrates an expandable and collapsible `DataGrid` using WPF with MVVM.

### Model: Person.cs

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string AdditionalDetails { get; set; }
    public bool IsExpanded { get; set; }
}
```

### ViewModel: MainViewModel.cs

```csharp
using System.Collections.ObjectModel;

public class MainViewModel
{
    public ObservableCollection<Person> Persons { get; set; }

    public MainViewModel()
    {
        Persons = new ObservableCollection<Person>
        {
            new Person { Name = "John", Age = 30, AdditionalDetails = "Likes reading" },
            new Person { Name = "Jane", Age = 25, AdditionalDetails = "Enjoys hiking" },
            new Person { Name = "Emily", Age = 20, AdditionalDetails = "Loves painting" },
            new Person { Name = "Mike", Age = 35, AdditionalDetails = "Avid cyclist" }
        };
    }
}
```

### View: MainWindow.xaml

```xaml
<Window x:Class="ExpandableDataGridExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Expandable Data Grid Example" Height="400" Width="600">
    <Grid>
        <DataGrid Name="ExpandableDataGrid" AutoGenerateColumns="False" ItemsSource="{Binding Persons}">
            <DataGrid.Columns>
                <DataGridTemplateColumn Width="SizeToCells" IsReadOnly="True">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Button Content="{Binding IsExpanded, Converter={StaticResource BoolToExpandCollapseConverter}}" 
                                    Command="{Binding DataContext.ToggleExpandCollapseCommand, RelativeSource={RelativeSource AncestorType=DataGrid}}"
                                    CommandParameter="{Binding}"/>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                <DataGridTextColumn Header="Name" Binding="{Binding Name}" />
                <DataGridTextColumn Header="Age" Binding="{Binding Age}" />
            </DataGrid.Columns>
            <DataGrid.RowDetailsTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Vertical">
                        <TextBlock Text="Additional Details" FontWeight="Bold"/>
                        <TextBlock Text="{Binding AdditionalDetails}" Margin="20,0,0,0"/>
                    </StackPanel>
                </DataTemplate>
            </DataGrid.RowDetailsTemplate>
        </DataGrid>
    </Grid>
</Window>
```

### Converters: BoolToExpandCollapseConverter.cs

```csharp
using System;
using System.Globalization;
using System.Windows.Data;

public class BoolToExpandCollapseConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return (bool)value ? "-" : "+";
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return (string)value == "-";
    }
}
```

### ViewModel Commands: Inside MainViewModel.cs

```csharp
using System.Windows.Input;

public ICommand ToggleExpandCollapseCommand { get; private set; }

public MainViewModel()
{
    // ... Existing code
    ToggleExpandCollapseCommand = new RelayCommand<Person>(ToggleExpandCollapse);
}

private void ToggleExpandCollapse(Person person)
{
    if (person != null)
    {
        person.IsExpanded = !person.IsExpanded;
    }
}
```

### RelayCommand.cs

Implement a simple `RelayCommand` class for the command binding.

```csharp
using System;
using System.Windows.Input;

public class RelayCommand<T> : ICommand
{
    private readonly Action<T> _execute;
    private readonly Predicate<T> _canExecute;

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public RelayCommand(Action<T> execute, Predicate<T> canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute((T)parameter);
    }

    public void Execute(object parameter)
    {
        _execute((T)parameter);
    }
}
```

Finally, don't forget to set your `MainWindow`'s `DataContext` to an instance of `MainViewModel`:

```csharp
// Inside MainWindow.xaml.cs constructor
DataContext = new MainViewModel();
```

In this example, each row is bound to a `Person` object. The `IsExpanded` property of each `Person` object determines whether the row is expanded or not. The button's `Command` toggles this property, and the button's content (either "+" or "-") is determined by a value converter that looks at the `IsExpanded` property.

Please note that you may need to adjust the code to fit your specific requirements.